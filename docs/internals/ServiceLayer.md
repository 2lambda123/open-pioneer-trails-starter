# Service Layer

This document contains details about the implementation of the pioneer runtime's service layer.
It should aid developers to gain an understanding of the implementation in order to maintain or extend it.

The service layer provides a generic dependency injection mechanism in which services can be defined.
Services may reference each other through references, forming a graph of services.

See [Design](./Design.md) for some background information.

## Overview

The service layer's implementation lives in the package `@open-pioneer/runtime`, mostly in the `services` directory.
It is heavily inspired by the Spring framework.

The most important classes and modules are:

-   `class ServiceLayer`

    Responsible for maintaining the service lifecycle.
    This involves starting all required services, connecting them via references and destroying them again when the system shuts down.

-   `function verifyDependencies`

    The service layer will verify the services' dependency graph before starting them by calling this function.
    It will visit all services to ensure that their dependencies can be fulfilled and that no cycles occur.
    On error, the method will output sensible error messages that can be easily understood by the developer.

    In its current form, the function essentially ensures that the dependency graph is an acyclic graph.

-   `class PackageRepr` / `ServiceRepr`

    Represents a package / service at runtime.
    It must be noted that these classes are stateful: their state will reflect the changes made by the service layer.
    For example, a `ServiceRepr`'s `instance` attribute will hold the actual service instance once it has been created.
    As a consequence, they cannot be reused or shared between multiple application instances.

-   `function parsePackages`

    Parses metadata into instances of `PackageRepr` and `ServiceRepr`.
    This transforms the well defined metadata format (input to the service layer) into the internal runtime representation.

## Metadata format

The metadata format is currently maintained in the runtime package at `@open-pioneer/runtime/metadata`.
It describes packages, services and their associated metadata (such as references, provided interfaces, etc.).
In most instances, the metadata will be autogenerated by build tools.
However, it can also be provided manually (see tests).

The metadata format should be stable: it is part of the public interface.
When the metadata format is altered, the build tooling will (most likely) have to be updated as well.

## Service Layer Lifecycle

1. _Construction_

    The service layer is constructed from a set of `PackageRepr`.
    It will immediately verify and index the services in the dependency graph.
    The construction is currently triggered from the custom element class when it is connected to the DOM.

2. _start_

    The `start()` method is called.
    It currently launches all services by calling `createService`, whether they are needed or not.

    `createService` is recursive: a service's dependencies must be created before the service itself can be created.

    The process to construct a service `s` is as follows:

    1. Has `s` already been constructed? Return `s.instance` and increment its reference count.
    2. Is the service in any other state than `not-constructed`? Throw an error (this is a sanity check, since `verifyDependency` should have caught the issue).
    3. Call `createService(d)` for every service `d` required by `s` and store the instance reference.
    4. Finally create the service `s` by passing the required references and other parameters into its constructor.
       Note that this initializes service's reference count to `1`.

    `start()` tracks the number of times a service is being used as a dependency.
    This is needed during shutdown.

3. The application runs.
   Services may call each other's methods.

4. _destroy_

    The `destroy()` is being called on the service layer.
    This currently happens when the custom component is removed from the DOM.

    Destruction reverses the process in `start()`.

    `destroyService(s)` is called for every service:

    1. Is the service already destroyed? Do nothing and return.
    2. Remove a reference from `s`.
       It is no longer used and can be safely destroyed if the count reaches zero.
    3. Call `destroyService(d)` for every dependency of `s`.
       It is imported to destroy the dependencies _after_ the service has been destroyed,
       because the service's destructor may still reference its dependencies.

## Limitations

### Unique implementations only

An interface can currently only be implemented once.
An error is thrown if multiple classes provide the same interfaces.

This can be relaxed in the future:

-   When an interface is implemented multiple times, a tag could be used to discriminate the instances.
    It is important to remain unambiguous: if no clear service can be chosen from a set, an error should be thrown (don't just pick an arbitrary one!).

### 1-to-1 dependencies only

There are no one to many dependencies at this time.
This is trivially the case because an interface can only be implemented once (see above).

It makes sense to relax this restriction in the future.
Example use case: "get all tools".

### Cycles are forbidden

A service cannot depend on itself (directly or indirectly).
Such a thing would be impossible to implement (reasonably) because a dependency should be fully initialized
before it is being used.

We currently verify that there are no cycles through static analysis.
This should remain the default case: most reference to other services should be static.
Tooling such as the `verifyDependencies` function can then provide useful analysis to prevent (or diagnose) common errors.

The restriction can still be relaxed when a service depends on itself statically but is only dynamically used once fully constructed;
in other words, if the cycle is "resolved" once the first service method is actually being called.

The way this could be implemented is by declaring a dependency as _lazy_.
A reference would still be injected into the service's constructor, but it will only be proxy object that _must not_ be used in a cycle.
Such a reference cannot be verified statically and should therefore only used at carefully chosen locations to break cycles.

Example:

```js
class MyService {
    constructor({ references }) {
        const actuallyMyself = references.myself; // not a MyService, but a Lazy<MyService>
        this.actuallyMyself = actuallyMyself;

        // Would throw because myself has not been fully constructed yet!
        actuallyMyself.get().foo();
    }

    bar() {
        // Works because by now the service has been constructed.
        // This requires runtime checks inside get().
        this.actuallyMyself.get().foo();
    }

    foo() {
        console.log("Hello World");
    }
}
```

### Unneeded services are started

We currently start all services, whether they are needed or not.
In the future, only needed services should be started.

It would also be desirable to output which services are not needed (or to optimize them away outright at build time).
